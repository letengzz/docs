# 消息队列MQ

## 为什么要用消息队列

使用消息队列有以下几个主要原因：

1. 解耦和提高系统可靠性：消息队列提供了解耦的方式，发送方和接收方之间不直接进行通信，通过消息队列中转。这样，即使其中一个组件或者系统出现故障，不会影响到整个系统的正常运行。
2. 异步处理和提高系统性能：消息队列可以使发送方和接收方异步处理消息。发送方将消息发送到队列中后，不需要等待接收方立即处理，而是可以继续处理其他任务。这样可以提高系统的性能和响应速度。
3. 缓冲和流量控制：消息队列可以作为缓冲区，用于处理流量峰值。当系统面临突发的请求量增加时，消息队列可以缓冲请求并逐渐处理，避免系统过载。
4. 同步数据：在分布式系统中，不同组件或者系统之间可能需要共享数据。通过消息队列可以实现数据的同步和共享，保证各个组件之间的数据一致性。
5. 扩展和灵活性：使用消息队列可以通过增加消费者来实现系统的扩展性，并且消费者可以根据需求灵活地进行扩缩容。这样可以根据实际需求进行系统的调整和优化。

## 缺点

- **系统可用性降低**：如果消息队列挂了，系统服务会出现问题。因此，系统可用性会降低； 

- **系统复杂度提高**：加入了消息队列，要多考虑很多方面的问题，比如：一致性问题、如何保证消息不被重复消费、如何保 证消息可靠性传输等。因此，需要考虑的东西更多，复杂性增大。 

- **一致性问题**：A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。所以消息队列实际是一种非常复杂的架构，你引入它有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，做好之后，你会发现，妈呀，系统复杂度提升了一个数量级，也许是复 杂了 10 倍。但是关键时刻，用，还是得用的。

## 简述及选型

**简述**：

MQ主要是用于在消息的运输过程中保存消息的容器，是一个先进先出的数据结构，多用于分布式系统之间进行通信。

**举例**：比如qq，微信这些都是典型的MQ场景

消息由生产者发送到MQ进行排队，然后由消费者对消息进行处理。

------

**选型**：

主流Kafka、RabbitMQ、RocketMQ

**主要是根据自己的业务场景选型**：

**Kafka**：

- **优点**：
  - 吞吐量非常大
  - 性能非常好
  - 集群高可用

- **缺点**：
  - 当Topic多的时候 Kafka性能和响应不稳定，消息可能会丢失，需要对二次改造因为在Kafka中每个Topic都会有自己的目录，产出的文件比较多，打开的文件就会越多 就会影响IO操作，从而造成不稳定
  - 场景固定，像死信队列 高级功能不存在 只关注性能和吞吐量

- **使用场景**：
  - 数据量大，比较频繁，可以允许数据丢失的现象
  - 比如：日志分析、大数据采集


**RabbitMQ**：

- **优点**：
  - 消息可靠性高、功能全面

- **缺点**：
  - 吞吐量比较低，消息积累会严重影响性能
  - erlang语言不好定制

- **使用场景**：小规模场景。比如：简单的系统通知

**RocketMQ**：

- **优点**：
  - 高吞吐(针对RabbitMQ)、高可用、功能非常全面
  - 源码是Java开发 

- **缺点**：
  - 开源版功能不如云上商业版
  - 官方文档和周边生态不够成熟
  - 客户端只支持Java

- **使用场景**：几乎是全场景。

## **你们公司生产环境用的是什么消息中间件？**

这个首先你可以说下你们公司选用的是什么消息中间件，比如用的是RabbitMQ，然后可以初步给一些你对不同MQ中间件技术的选型分析。 

举个例子：比如说ActiveMQ是老牌的消息中间件，国内很多公司过去运用的还是非常广泛的，功能很强大。 

但是问题在于没法确认ActiveMQ可以支撑互联网公司的高并发、高负载以及高吞吐的复杂场景，在国内互联网公司落地较少。而且使用较多的是一些传统企业，用ActiveMQ做异步调用和系统解耦。 

然后你可以说说RabbitMQ，他的好处在于可以支撑高并发、高吞吐、性能很高，同时有非常完善便捷的后台管理界面可以使用。 

另外，他还支持集群化、高可用部署架构、消息高可靠支持，功能较为完善。 而且经过调研，国内各大互联网公司落地大规模RabbitMQ集群支撑自身业务的case较多，国内各种中小型互联网公司使用RabbitMQ的实践也比较多。 

除此之外，RabbitMQ的开源社区很活跃，较高频率的迭代版本，来修复发现的bug以及进行各种优化，因此综合考虑过后，公司采取了RabbitMQ。 

但是RabbitMQ也有一点缺陷，就是他自身是基于erlang语言开发的，所以导致较为难以分析里面的源码，也较难进行深层次的源码定制和改造，毕竟需要较为扎实的erlang语言功底才可以。 

然后可以聊聊RocketMQ，是阿里开源的，经过阿里的生产环境的超高并发、高吞吐的考验，性能卓越，同时还支持分布式事务等特殊场景。 

而且RocketMQ是基于Java语言开发的，适合深入阅读源码，有需要可以站在源码层面解决线上生产问题，包括源码的二次开发和改造。 

另外就是Kafka。Kafka提供的消息中间件的功能明显较少一些，相对上述几款MQ中间件要少很多。 

但是Kafka的优势在于专为超高吞吐量的实时日志采集、实时数据同步、实时数据计算等场景来设计。

因此Kafka在大数据领域中配合实时计算技术（比如Spark Streaming、Storm、Flink）使用的较多。但是在传统的MQ中间件使用场景中较少采用。

## MQ的作用

- **异步**：异步能提高系统的响应速度和吞吐量。举例：快递员直接将快递送到客户家签收，客户不在家 需要多次投递，影响了效率。使用菜鸟驿站，快递只需要将快递送到菜鸟驿站 客户可以随时签收。客户不用等快递员，快递员也不用等客户
- **解耦**：系统耦合度越高，容错性就越低。服务之间进行解耦，可以减少服务之间的影响，提高系统的稳定性和可扩展性。解耦之后可以实现数据分发。生产者发送一个消息，可以由多个消费者来处理(比如下单时，后面很多事情 发起支付，库存减一等 服务叠加的很多 如果用MQ就可以发送一个消息，各个模块消费消息)。举例：Java项目调用Python程序模块，可以将任务以一个消息的形式发送到MQ，Python用MQ消费消息，结果也可以通过MQ方式进行响应或者数据库的响应
- **削峰填谷**：以稳定的系统资源应对突发的流量冲击。所有的消息先到MQ中缓存起来，然后后台慢慢下单举例：长江涨水可以暂时存储 然后慢慢流出 (接入层的流量通过MQ将流量缓慢的输入到服务层)

但是MQ的缺点：

- 系统的可用性降低：一旦MQ宕机，整个业务就会影响。需要考虑MQ 的高可用
- 系统的复杂度提高：引入MQ之后，数据链路就会变得很复杂。比如保证消息不丢失，消息不会重复调用，怎么保证消息的顺序性
- 数据一致性问题：A系统发消息，需要由B、C两个系统一同处理。如果B系统处理成功，C系统处理失败，这就会造成数据一致性的问题

## 业务架构/原理

### RocketMQ

RocketMQ主要由Producer集群、Broker集群、Consumer集群、NameServer集群四部分组成，Producer负责生产消息、Consumer负责消费消息，Broker负责存储消息，NameServer作为路由中心，用于服务的注册和发现，协调其他的服务。

Broker在实际部署过程中对应一台服务器。每个Broker可以存储多个Topic的消息，每个Topic的消息也可以分片存储到不同的Broker。队列 用于存储消息的物理地址，每个Topic中的消息地址存储于多个队列中

**消息生产和消费的大致原理**：

1. Broker 在启动的时候向所有的NameServer注册，并保持长连接，每30s发送一次
2. Producer在发送消息的时候从NameServer获取Broker服务器地址，根据负载均衡算法选择一台服务器来发送消息到Broker，Broker将消息存储在Topic中。
3. Consumer消费消息的时候同样从NameServer获取Broker地址，然后主动从Broker订阅Topic并拉取消息来消费

### RabbitMQ

- Produer发送消息到Exchange交换机
- 交换机会将消息路由到对应的队列中
- Consumer 直接拿到队列里面的消息来进行消费

## 如何保证消息不丢失

- RabbitMQ：
  - 确保消息到MQ：发送方的确认模式，发送失败考虑重发
  - 确保消息路由到正确的队列：路由失败通知
  - 确保消息在队列正确的存储：交换器、队列、消息都需要持久化
  - 确保消息从队列中正确的投递到消费者：手动确认，交给消费者来确认，没有消费成功要求mq重新发，失败多次会进入死信队列

## 处理消息重复

- RabbitMQ：

  - 发送的消息存在重复发送

    - 消息发送端发送消息给消息中间件，消息中间件收到消息并成功存储，而这时消息中间件出现了问题，导致应用端中间件出现了问题，导致应用端没有收到消息发送成功的返回因而进行重试产生了重复
    - 消息中间件因为负载高响应变慢，成功把消息存储到消息存储中后，成功的结果超时了
    - 消息中间件将消息成功写入消息存储，在返回结果时网络出现问题，导致应用发送端重试，而重试时网络恢复，因此导致重复

    可以看到，通过消息发送端产生消息重复的主要原因是消息成功进入消息存储后，因为各种原因使得消息发送端没有收到成功的返回结果，并且又有重试机制而导致重复

  - 由中间件进行向外的投递产生重复

    - 消息被投递到消息接收者应用进行处理，处理完毕后应用出现问题了，

