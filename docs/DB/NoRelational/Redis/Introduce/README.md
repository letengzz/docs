# Redis 概述

Redis(远程字典服务器，**RE**mote **Di**ctionary **S**erver) 是一个开源的**高性能的基于内存的键值对(Key-Value)数据库**。使用ANSIC语言编写遵守BSD协议，提供了丰富的数据结构，例如String、Hash、List、Set、SortedSet等适应不同场最下的存储需求，并借助许多高层级的接口使其可以胜任如缓存、队列系统等不同的角色。数据是存在内存中的，同时Redis支持事务、持久化、LUA脚本、发布/订阅、缓存淘汰、流技术等多种功能特性提供了主从模式、Redis Sentinel和Redis Cluster集群架构方案。

**官方地址**：

- https://redis.io
- http://www.redis.cn
- https://www.redis.com.cn/documentation.html

**Redis 源码地址**：https://github.com/redis/redis

**Redis 在线测试**：https://try.redis.io

**Redis 命令参考**：http://doc.redisfans.com

**Redis之父安特雷兹**：Redis之父Salvatore Sanfilippo，一名意大利程序员，大家更习惯称呼他Antirez

- Github：https://github.com/antirez
- 个人博客：http://antirez.com/latest/0

**特性**：

- K-V存储结构
- 内存存储与持久化
- 功能丰富
- 简单稳定

![](https://fastly.jsdelivr.net/gh/LetengZzz/img@main/tc2/img%E4%B8%8B%E8%BD%BD%20.png)

## 引用

很多大厂的 Redis 服务面临的请求规模很大，因此，在评估性能时，仅仅看平均延迟已经不够了。假设 Redis 处理了 100 个请求，99 个请求的响应时间 都是 1s，而有一个请求的响应时间是 100s。那么，如果看平均延迟，这 100 个请求的平均延迟是 1.99s，但是对于这个响应时间是 100s 的请求而言，它对应的用户体验将是非常糟糕的。如果有 100 万个请求，哪怕只有 1% 的请求是 100s，这也对应了 1 万个糟糕的 用户体验。这 1% 的请求延迟就属于长尾延迟。

影响 Redis 性能的关键因素路径：首先，对 Redis 的线程模型做分析：对于单线程的 Redis 而言，任何阻塞性操作都会导致长尾延迟的产生。可能导致阻塞的关键因素也可能是网络阻塞，但Redis 网络 IO 使用了 IO 复用机制，并不会阻塞在单个客户端上。当然也可能是键值对数据结构、持久化机制下的 fork 调用、主从库同步时的 AOF 重写，以及缓冲区溢出等多个方面。这条影响长尾延迟的“证据 链”才得以形成。

缓存和集群是 Redis 的两大广泛的应用场景。在这些场景中，本身就具有一条 显式的技术链。比如说，提到缓存场景，肯定会想到缓存机制、缓存替换、缓存异常等 一连串的问题。

不过，并不是所有的东西都适合采用这种方式，比如说 Redis 丰富的数据模型，就导致它 有很多零碎的应用场景，很多很杂。而且，还有一些问题隐藏得比较深，只有特定的业务 场景下(比如亿级访问压力场景)才会出现，并不是普遍现象，所以，也比较难于梳理出结构化的体系。

## 两大维度/三大主线

"**两大维度**"：

- 系统维度
- 应用维度

"**三大主线**"：简称为"三高"

- 高性能：线程模型、数据结构、持久化、网络框架
- 高可靠：主从复制、哨兵机制
- 高可扩展：数据分片、负载均衡

![](https://fastly.jsdelivr.net/gh/LetengZzz/img@main/tc2/img%E4%B8%8B%E8%BD%BD.jpeg)

## 应用场景

![](https://fastly.jsdelivr.net/gh/LetengZzz/img@main/tc2/img%E4%B8%8B%E8%BD%BD-9914224.png)

- **分布式缓存**：与传统数据库关系(mysql)，Redis是key-value数据库(NoSQL一种)，mysql是关系数据库

  Redis数据操作主要在内存，而mysql主要存储在磁盘

  Redis在某一些场景使用中要明显优于DBMS，比如计数器、排行榜等方面

  Redis通常用于一些特定场景，需要与DBMS 一起配合使用，两者并不是相互替换和竞争关系，而是共用和配合使用，客户端从 DBMS 中查询出的数据首先写入到 Redis 中，后续无论哪个客户端再需要访问该数据，直接读取 Redis 中的即可，不仅减小了 RT，而且降低了 DBMS 的压力。

  ![](https://fastly.jsdelivr.net/gh/LetengZzz/img@main/tc2/img%E4%B8%8B%E8%BD%BD.png)

  根据 Redis 缓存的数据与 DBMS 中数据的同步性划分：

  - **同步缓存**：实时同步缓存是指，DBMS 中数据更新后，Redis 缓存中的存放的相关数据会被立即清除，以促使再有对该数据的访问请求到来时，必须先从 DBMS 中查询获取到最新数据，然后再写入到 Redis。
  - **阶段性同步缓存**：阶段性同步缓存是指，Redis 缓存中的数据允许在一段时间内与 DBMS 中的数据不完全一致。而这个时间段就是这个缓存数据的过期时间。

- **内存存储和持久化**：内存存储和持久化(RDB+AOF) ，Redis支持异步将内存中的数据写到硬盘上，同时不影响继续服务

- **高可用架构搭配**：单机、主从、哨兵、集群。

- **分布式锁**

- **队列**：Reids提供list和set操作，这使得Redis能作为一个很好的消息队列平台来使用。通过Reids的队列功能做购买限制。比如到节假日或者推广期间，进行一些活动，

  可以对用户购买行为进行限制，限制今天只能购买几次商品或者一段时间内只能购买一次。也比较适合适用。

- **排行榜+点赞**：在互联网应用中，有各种各样的排行榜，如电商网站的月度销量排行榜、社交APP的礼物排行榜、小程序的投票排行榜等等。Redis提供的zset数据类型能够快速实现这些复杂的排行榜。

  比如小说网站对小说进行排名，根据排名，将排名靠前的小说推荐给用户

## 优势

- **性能极高**：Redis能读的速度是110000次/秒，写的速度是81000次/秒
- **数据类型丰富**：不仅仅支持简单的key-value类型的数据，同时提供list、set、zset、hash等数据结构的存储
- **持久化**：可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用
- **数据备份**：master-slave模式的数据备份

![](https://fastly.jsdelivr.net/gh/LetengZzz/img@main/tc2/img202404072217680.png)

## 命名规则

Redis从发布至今，已经有十余年的时光了，一直遵循着自己的命名规则：

- 版本号第二位如果是奇数，则为非稳定版本 如2.7、2.9、3.1

- 版本号第二位如果是偶数，则为稳定版本 如2.6、2.8、3.0、3.2

当前奇数版本就是下一个稳定版本的开发版本，如2.9版本是3.0版本的开发版本

 历史发布版本源码：https://download.redis.io/releases/
