# HikariCP

HikariCP 源于日语“光る”，光的意思，寓意软件工作速度和光速一样快，它是 SpringBoot 中默认的数据库连接池。

数据库是工作中经常使用到的组件，针对数据库设计的客户端连接池是非常多的，它可以有效地减少数据库连接创建、销毁的资源消耗。

同是连接池，它们的性能也是有差别的，下图是 HikariCP 官方的一张测试图，可以看到它优异的性能，官方的 JMH 测试代码见 Github。

![img](https://fastly.jsdelivr.net/gh/LetengZzz/img@main/img/202502221826690.png)

HikariCP 速度快，主要有三个方面：

- 它使用 FastList 替代 ArrayList，通过初始化的默认值，减少了越界检查的操作
- 优化并精简了字节码，通过使用 Javassist，减少了动态代理的性能损耗，比如使用 invokestatic 指令代替 invokevirtual 指令
- 实现了无锁的 ConcurrentBag，减少了并发场景下的锁竞争

数据库连接池同样面临一个最大值（maximumPoolSize）和最小值（minimumIdle）的问题。这里同样有一个非常高频的面试题：你平常会把连接池设置成多大呢？

很多同学认为，连接池的大小设置得越大越好，有的同学甚至把这个值设置成 1000 以上，这是一种误解。

根据经验，数据库连接，只需要 20~50 个就够用了。具体的大小，要根据业务属性进行调整，但大得离谱肯定是不合适的。

HikariCP 官方是不推荐设置 minimumIdle 这个值的，它将被默认设置成和 maximumPoolSize 一样的大小。如果你的数据库Server端连接资源空闲较大，不妨也可以去掉连接池的动态调整功能。

另外，根据数据库查询和事务类型，一个应用中是可以配置多个数据库连接池的，这个优化技巧很少有人知道，在此简要描述一下。

业务类型通常有两种：一种需要快速的响应时间，把数据尽快返回给用户；另外一种是可以在后台慢慢执行，耗时比较长，对时效性要求不高。

如果这两种业务类型，共用一个数据库连接池，就容易发生资源争抢，进而影响接口响应速度。

虽然微服务能够解决这种情况，但大多数服务是没有这种条件的，这时就可以对连接池进行拆分。

如图，在同一个业务中，根据业务的属性，分了两个连接池，就是来处理这种情况的。

![image-20250222182735399](https://fastly.jsdelivr.net/gh/LetengZzz/img@main/image-20250222182735399.png)

HikariCP 还提到了另外一个知识点，在 JDBC4 的协议中，通过 Connection.isValid() 就可以检测连接的有效性。

这样，我们就不用设置一大堆的 test 参数了，HikariCP 也没有提供这样的参数。

**结果缓存池**

到了这里可能会发现池（Pool）与缓存（Cache）有许多相似之处。

它们之间的一个共同点，就是将对象加工后，存储在相对高速的区域。我习惯性将缓存看作是数据对象，而把池中的对象看作是执行对象。缓存中的数据有一个命中率问题，而池中的对象一般都是对等的。

考虑下面一个场景，jsp 提供了网页的动态功能，它可以在执行后，编译成 class 文件，加快执行速度；再或者，一些媒体平台，会将热门文章，定时转化成静态的 html 页面，仅靠 nginx 的负载均衡即可应对高并发请求（动静分离）。

这些时候，很难说清楚，这是针对缓存的优化，还是针对对象进行了池化，它们在本质上只是保存了某个执行步骤的结果，使得下次访问时不需要从头再来。

通常把这种技术叫作结果缓存池（Result Cache Pool），属于多种优化手段的综合。

如下图，可以看到数据库连接池连接数长时间保持在高位不释放，同时等待的线程数急剧增加，这就能快速定位到数据库的事务问题。

![图片](https://fastly.jsdelivr.net/gh/LetengZzz/img@main/img/202502221828129.png)