# 微服务的拆分

微服务相对于之前的庞大的单体架构项目来说，单个服务的形式更容易维护开发、局部修改更加容易，技术栈选择更加灵活，所以越来越多的技术团队都更倾向于使用微服务技术栈，但是，一说到微服务，服务的拆分是绕不开的的话题，服务不是说拆就能拆的，有很多的前提条件。

## 服务拆分的前提

- 首先要有一个持续集成的平台，使得服务在拆分的过程中，功能的一致性，这种一致性不能通过人的经验来，而需要经过大量的回归测试集，并且持续的拆分，持续的演进，持续的集成，从而保证系统时刻处于可以验证交付的状态，而非闭门拆分一段时间，最终谁也不知道功能最终究竟有没有bug，因而需要另外一个月的时间专门修改bug。

- 其次在接入层，API和UI要动静分离，API由API网关统一的管理，这样后端无论如何拆分，可以保证对于前端来讲，统一的入口，而且可以实现拆分过程中的灰度发布，路由分发，流量切分，从而保证拆分的平滑进行。而且拆分后的微服务之间，为了高性能，是不建议每次调用都进行认证鉴权的，而是在API网关上做统一的认证鉴权，一旦进入网关，服务之间的调用就是可信的。

- 其三对于数据库，需要进行良好的设计，不应该有大量的联合查询，而是将数据库当成一个简单的key-value查询，复杂的联合查询通过应用层，或者通过Elasticsearch进行。如果数据库表之间耦合的非常严重，其实服务拆分是拆不出来的。

## 微服务拆分时机

### 微服务拆分时机一

提交代码频繁出现大量冲突

微服务对于快速迭代的效果，首先是开发独立，如果是一单体应用，几百人开发一个模块，如果使用Git做代码管理，则经常会遇到的事情就是代码提交冲突。同样一个模块，你也改，他也改，几百人根本没办法沟通。所以当你想提交一个代码的时候，发现和别人提交的冲突了，于是因为你是后提交的人，你有责任去merge代码，好不容易merge成功了，等再次提交的时候，发现又冲突了，你是不是很恼火。随着团队规模越大，冲突概率越大。

所以应该拆分成不同的模块，每十个人左右维护一个模块，也即一个工程，首先代码冲突的概率小多了，而且有了冲突，一个小组一吼，基本上问题就解决了。每个模块对外提供接口，其他依赖模块可以不用关注具体的实现细节，只需要保证接口正确就可以。

### 微服务拆分时机二

小功能要积累到大版本才能上线，上线开总监级别大会

微服务对于快速迭代的效果，首先是上线独立。如果没有拆分微服务，每次上线都是一件很痛苦的事情。当你修改了一个边角的小功能，但是你不敢马上上线，因为你依赖的其他模块才开发了一半，你要等他，等他好了，也不敢马上上线，因为另一个被依赖的模块也开发了一半，当所有的模块都耦合在一起，互相依赖，谁也没办法独立上线，而是需要总监协调各个团队，大家开大会，约定一个时间点，无论大小功能，死活都要这天上线。

这种模式导致上线的时候，单次上线的需求列表非常长，这样风险比较大，可能小功能的错误会导致大功能的上线不正常，将如此长的功能，需要一点点check，非常小心，这样上线时间长，影响范围大。因而这种的迭代速度快不了，顶多一个月一次就不错了。服务拆分后，在接口稳定的情况下，不同的模块可以独立上线。这样上线的次数增多，单次上线的需求列表变小，可以随时回滚，风险变小，时间变短，影响面小，从而迭代速度加快。对于接口要升级部分，保证灰度，先做接口新增，而非原接口变更，当注册中心中监控到的调用情况，发现接口已经不用了，再删除。

微服务解决的问题之二，就是高并发，互联网一个产品的特点就是在短期内要积累大量的用户，这甚至比营收和利润还重要，如果没有大量的用户基数，融资都会有问题。因而对于并发量不大的系统，进行微服务化的驱动力差一些，如果只有不多的用户在线，多线程就能解决问题，最多做好无状态化，前面部署个负载均衡，单体应用部署多份。

### 微服务拆分时机三

横向扩展流程复杂，主要业务和次要业务耦合

单体应用无状态化之后，虽然通过部署多份，可以承载一定的并发量，但是资源非常浪费。因为有的业务是需要扩容的，例如下单和支付，有的业务是不需要扩容的，例如注册。如果一起扩容，消耗的资源可能是拆分后的几倍，成本可能多出几个亿。而且由于配置复杂，在同一个工程里面，往往在配置文件中是这样组织的，这一块是这个模块的，下一块是另一个模块的，这样扩容的时候，一些边角的业务，也是需要对配置进行详细审核，否则不敢贸然扩容。

### 微服务拆分时机四

熔断降级全靠 if-else

在高并发场景下，我们希望一个请求如果不成功，不要占用资源，应该尽快失败，尽快返回，而且希望当一些边角的业务不正常的情况下，主要业务流程不受影响。这就需要熔断策略，也即当 A 调用 B，而 B 总是不正常的时候，为了让 B 不要波及到 A，可以对 B 的调用进行熔断，也即 A 不调用 B，而是返回暂时的fallback数据，当 B 正常的时候，再放开熔断，进行正常的调用。

有时候为了保证核心业务流程，边角的业务流程，如评论，库存数目等，人工设置为降级的状态，也即默认不调用，将所有的资源用于大促的下单和支付流程。如果核心业务流程和边角业务流程在同一个进程中，就需要使用大量的if-else语句，根据下发的配置来判断是否熔断或者降级，这会使得配置异常复杂，难以维护。

如果核心业务和边角业务分成两个进程，就可以使用标准的熔断降级策略，配置在某种情况下，放弃对另一个进程的调用，可以进行统一的维护。

## 业界流行的微服务拆分方法论

- 领域驱动设计 (`DDD`、`Domian Driven Design`)

- 面向对象 (`by name./by verb.`)

- 职责划分、通用性划分

- 微服务拆分粒度

- 良好满足业务

- 增量迭代和持续进化

## 服务拆分的规范

- 服务拆分的规范一：服务拆分最多三层，两次调用

- 服务拆分的规范二：仅仅单向调用，严禁循环调用

- 服务拆分的规范三：将串行调用改为并行调用，或者异步化

- 服务拆分的规范四：接口应该实现幂等

- 服务拆分的规范五：接口数据定义严禁内嵌，透传

- 服务拆分的规范六：规范化工程名

## 总结

微服务拆分其实目前来说没有以及具体的原则和标准可以参考，主要拆分原则遵循无非是以下几个方面：

- 单一职责、高内聚低耦合：简单来说一张表划分为一个服务。

- 通用性划分的形式，比如大中台 / 小中台。

- 服务粒度适中：服务不要太细（有的团队甚至一个接口一个服务）。

- 以业务模型切入：比如产品，用户，订单为一个模型来切入。

- 演进式拆分：刚开始不要划分太细，可以随着迭代过程来逐步优化。

- 避免环形依赖与双向依赖：尽量不要做服务之间的循环依赖。
